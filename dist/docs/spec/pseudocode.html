<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pseudocode Design | Documentation</title>

    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="../../assets/style.css">
    <link rel="stylesheet" href="../../assets/syntax-highlighting.css">
    <script src="../../assets/highlight.js"></script>
</head>
<body>
    <div class="layout">
        
        <header class="header">
            <div class="header-content">
                <div style="display: flex; align-items: center; gap: var(--spacing-xl);">
                    <button class="menu-toggle" onclick="toggleSidebar()">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                    </button>
                    <div class="logo">Documentation</div>
                </div>
                <nav class="header-nav">
                    <a href="#" class="header-link">Docs</a>
                    <a href="#" class="header-link">API</a>
                    <a href="#" class="header-link">GitHub</a>
                </nav>
            </div>
        </header>

        
        <aside class="sidebar" id="sidebar">
            
            <div class="search-container">
                <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <input type="text" class="search-input" placeholder="Search documentation...">
            </div>

            
            <nav>
                <div class="nav-section"><div class="nav-section-title">.tks</div><ul class="nav-list"><div class="nav-section"><div class="nav-section-title">Done</div><ul class="nav-list"><li class="nav-item"><a href="../../.tks/done/toc_searchability_improvements.html" class="nav-link">TOC Searchability Improvements for Scale</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Protocols</div><ul class="nav-list"><li class="nav-item"><a href="../../.tks/protocols/protodoc.html" class="nav-link">Complete Acronym Protocol Reference</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Support</div><ul class="nav-list"><li class="nav-item"><a href="../../.tks/support/jot_integration_strategy.html" class="nav-link">Jot Integration: Automating Documentation Updates</a></li></ul></div></ul></div><div class="nav-section"><ul class="nav-list"><li class="nav-item"><a href="../../README.html" class="nav-link">Jot</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Docs</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/CHANGELOG.html" class="nav-link">Changelog</a></li><div class="nav-section"><div class="nav-section-title">Benchmarks</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/benchmarks/stripe-docs-test.html" class="nav-link">Benchmarks</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Release</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/release/RELEASE-v0.1.0.html" class="nav-link">Jot v0.1.0 Release</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Roadmaps</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/roadmaps/rmap_01.html" class="nav-link">Roadmap</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Spec</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/spec/architecture.html" class="nav-link">System Architecture</a></li><li class="nav-item"><a href="../../docs/spec/pseudocode.html" class="nav-link active">Pseudocode Design</a></li><li class="nav-item"><a href="../../docs/spec/requirements.html" class="nav-link">Requirements Spec.</a></li></ul></div><div class="nav-section"><div class="nav-section-title">Strategies</div><ul class="nav-list"><li class="nav-item"><a href="../../docs/strategies/dimension_reduction.html" class="nav-link">Dimension Reduction Strategy</a></li><li class="nav-item"><a href="../../docs/strategies/downstream_usage.html" class="nav-link">Downstream Usage Strategy</a></li><li class="nav-item"><a href="../../docs/strategies/embedding_chunking.html" class="nav-link">Embedding & Chunking Strategy</a></li><li class="nav-item"><a href="../../docs/strategies/post_processing.html" class="nav-link">Post-Processing Strategy</a></li><li class="nav-item"><a href="../../docs/strategies/storage_schemas.html" class="nav-link">Storage Schemas Strategy</a></li></ul></div></ul></div><div class="nav-section"><ul class="nav-list"><li class="nav-item"><a href="../../p.html" class="nav-link">Untitled</a></li></ul></div>
            </nav>
        </aside>

        
        <main class="main">
            <div class="content">
                
                <nav class="breadcrumbs">
                    
                        
                        <a href="../../index.html" class="breadcrumb-link">Home</a>
                    
                        <span class="breadcrumb-separator">/</span>
                        <a href="../../docs.html" class="breadcrumb-link">Docs</a>
                    
                        <span class="breadcrumb-separator">/</span>
                        <a href="../../docs/spec.html" class="breadcrumb-link">Spec</a>
                    
                        <span class="breadcrumb-separator">/</span>
                        <a href="../../docs/spec/pseudocode.html" class="breadcrumb-link">Pseudocode</a>
                    
                </nav>

                
                <article>
                    <h1 id="pseudocode-design">Pseudocode Design</h1>

<h2 id="1-main-application-flow">1. Main Application Flow</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">PROGRAM Jot

INITIALIZE:
    config = LoadConfiguration()
    logger = SetupLogging()

MAIN:
    command = ParseCLIArguments()

    SWITCH command:
        CASE &quot;init&quot;:
            InitializeProject()
        CASE &quot;build&quot;:
            BuildDocumentation()
        CASE &quot;serve&quot;:
            StartWebServer()
        CASE &quot;watch&quot;:
            WatchAndRebuild()
        CASE &quot;export&quot;:
            ExportForLLM()
        DEFAULT:
            ShowHelp()
</code></pre>

<h2 id="2-file-scanning-algorithm">2. File Scanning Algorithm</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION ScanMarkdownFiles(rootPath, ignorePatterns):
    documents = []
    ignorer = CreateIgnoreFilter(ignorePatterns)

    FUNCTION WalkDirectory(path, relativePath):
        entries = ReadDirectory(path)

        FOR EACH entry IN entries:
            fullPath = JoinPath(path, entry.name)
            relPath = JoinPath(relativePath, entry.name)

            IF ignorer.ShouldIgnore(relPath):
                CONTINUE

            IF entry.IsDirectory():
                WalkDirectory(fullPath, relPath)
            ELSE IF entry.HasExtension(&quot;.md&quot;):
                doc = CreateDocument(fullPath, relPath)
                documents.APPEND(doc)

    WalkDirectory(rootPath, &quot;&quot;)
    RETURN documents

FUNCTION CreateDocument(filePath, relativePath):
    content = ReadFile(filePath)
    metadata = ExtractFrontmatter(content)
    title = ExtractTitle(content, metadata)

    RETURN Document{
        Path: filePath,
        RelativePath: relativePath,
        Content: content,
        Title: title,
        Metadata: metadata,
        ModTime: GetFileModTime(filePath)
    }
</code></pre>

<h2 id="3-toc-generation-algorithm">3. TOC Generation Algorithm</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION GenerateTableOfContents(documents):
    root = TOCNode{Title: &quot;Root&quot;, Children: []}

    FOR EACH doc IN documents:
        pathParts = SplitPath(doc.RelativePath)
        currentNode = root

        FOR i = 0 TO LENGTH(pathParts) - 1:
            part = pathParts[i]
            isFile = (i == LENGTH(pathParts) - 1)

            child = FindChildByName(currentNode, part)

            IF child == NULL:
                child = TOCNode{
                    ID: GenerateID(pathParts[0:i+1]),
                    Title: IF isFile THEN doc.Title ELSE Humanize(part),
                    Path: IF isFile THEN doc.RelativePath ELSE NULL,
                    Children: []
                }
                currentNode.Children.APPEND(child)

            currentNode = child

    RETURN ConvertToXML(root)

FUNCTION ConvertToXML(node):
    xml = &quot;&lt;toc version='1.0'&gt;\n&quot;

    FUNCTION ProcessNode(n, depth):
        indent = REPEAT(&quot;  &quot;, depth)

        IF n.Path != NULL:
            xml += indent + &quot;&lt;chapter id='&quot; + n.ID + &quot;' path='&quot; + n.Path + &quot;'&gt;\n&quot;
        ELSE:
            xml += indent + &quot;&lt;section id='&quot; + n.ID + &quot;'&gt;\n&quot;

        xml += indent + &quot;  &lt;title&gt;&quot; + EscapeXML(n.Title) + &quot;&lt;/title&gt;\n&quot;

        FOR EACH child IN n.Children:
            ProcessNode(child, depth + 1)

        xml += indent + (IF n.Path != NULL THEN &quot;&lt;/chapter&gt;\n&quot; ELSE &quot;&lt;/section&gt;\n&quot;)

    FOR EACH child IN node.Children:
        ProcessNode(child, 1)

    xml += &quot;&lt;/toc&gt;&quot;
    RETURN xml
</code></pre>

<h2 id="4-html-compilation-algorithm">4. HTML Compilation Algorithm</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION CompileToHTML(documents, tocXML, outputPath):
    toc = ParseXML(tocXML)
    linkMap = BuildLinkMap(documents)

    FOR EACH doc IN documents:
        html = ConvertMarkdownToHTML(doc.Content)
        html = ResolveInternalLinks(html, linkMap)
        html = AddSyntaxHighlighting(html)

        pageData = {
            Title: doc.Title,
            Content: html,
            TOC: toc,
            Breadcrumb: GenerateBreadcrumb(doc.RelativePath),
            Navigation: GenerateNavigation(doc, documents)
        }

        finalHTML = RenderTemplate(&quot;page.html&quot;, pageData)
        outputFile = JoinPath(outputPath, ChangeExtension(doc.RelativePath, &quot;.html&quot;))

        CreateDirectories(GetDirectory(outputFile))
        WriteFile(outputFile, finalHTML)

    CopyAssets(outputPath)
    GenerateSearchIndex(documents, outputPath)

FUNCTION ResolveInternalLinks(html, linkMap):
    PATTERN = /\[([^\]]+)\]\(([^)]+\.md[^)]*)\)/g

    RETURN html.REPLACE(PATTERN, FUNCTION(match, text, link):
        cleanLink = RemoveFragment(link)

        IF linkMap.HAS(cleanLink):
            htmlLink = ChangeExtension(linkMap[cleanLink], &quot;.html&quot;)
            RETURN &quot;[&quot; + text + &quot;](&quot; + htmlLink + &quot;)&quot;
        ELSE:
            RETURN match
    )
</code></pre>

<h2 id="5-search-implementation">5. Search Implementation</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION BuildSearchIndex(documents):
    index = {
        documents: [],
        terms: {},
        fuzzy: FuzzyMatcher{}
    }

    FOR EACH doc IN documents:
        docIndex = LENGTH(index.documents)

        index.documents.APPEND({
            id: doc.RelativePath,
            title: doc.Title,
            path: ChangeExtension(doc.RelativePath, &quot;.html&quot;)
        })

        // Extract and index terms
        terms = ExtractTerms(doc.Content + &quot; &quot; + doc.Title)

        FOR EACH term IN terms:
            normalizedTerm = Normalize(term)

            IF NOT index.terms.HAS(normalizedTerm):
                index.terms[normalizedTerm] = []

            index.terms[normalizedTerm].APPEND({
                doc: docIndex,
                count: CountOccurrences(doc.Content, term),
                positions: FindPositions(doc.Content, term)
            })

            index.fuzzy.Add(normalizedTerm)

    RETURN index

FUNCTION Search(query, index):
    results = []
    queryTerms = ExtractTerms(query)

    FOR EACH term IN queryTerms:
        normalized = Normalize(term)

        // Exact matches
        IF index.terms.HAS(normalized):
            FOR EACH occurrence IN index.terms[normalized]:
                AddToResults(results, occurrence)

        // Fuzzy matches
        fuzzyMatches = index.fuzzy.Find(normalized, maxDistance: 2)
        FOR EACH match IN fuzzyMatches:
            IF index.terms.HAS(match):
                FOR EACH occurrence IN index.terms[match]:
                    AddToResults(results, occurrence, fuzzyPenalty: 0.8)

    // Sort by relevance
    results.SORT(BY relevance DESCENDING)

    RETURN results.TAKE(maxResults: 20)
</code></pre>

<h2 id="6-llm-export-algorithm">6. LLM Export Algorithm</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION ExportForLLM(documents, format):
    SWITCH format:
        CASE &quot;json&quot;:
            RETURN ExportJSON(documents)
        CASE &quot;yaml&quot;:
            RETURN ExportYAML(documents)
        CASE &quot;embeddings&quot;:
            RETURN GenerateEmbeddings(documents)

FUNCTION ExportJSON(documents):
    export = {
        version: &quot;1.0&quot;,
        generated: CurrentTimestamp(),
        project: LoadProjectMetadata(),
        documents: []
    }

    FOR EACH doc IN documents:
        sections = ExtractSections(doc.Content)
        codeBlocks = ExtractCodeBlocks(doc.Content)
        links = ExtractLinks(doc.Content)

        export.documents.APPEND({
            id: GenerateDocID(doc.RelativePath),
            path: doc.RelativePath,
            title: doc.Title,
            content: doc.Content,
            html: ConvertToHTML(doc.Content),
            sections: sections,
            metadata: doc.Metadata,
            links: links,
            codeBlocks: codeBlocks
        })

    export.index = BuildSemanticIndex(export.documents)

    RETURN JSONStringify(export, pretty: true)

FUNCTION GenerateEmbeddings(documents):
    embeddings = []

    FOR EACH doc IN documents:
        chunks = SplitIntoChunks(doc.Content, maxTokens: 512, overlap: 128)

        FOR EACH chunk IN chunks:
            embedding = {
                documentId: doc.RelativePath,
                chunkId: GenerateChunkID(),
                text: chunk.text,
                vector: NULL,  // Placeholder for actual embedding
                metadata: {
                    title: doc.Title,
                    section: chunk.section,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine
                }
            }

            embeddings.APPEND(embedding)

    RETURN embeddings
</code></pre>

<h2 id="7-version-control-integration">7. Version Control Integration</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION InitializeVersionControl():
    vcs = {
        store: CreateFileStore(&quot;.jot-history&quot;),
        currentVersion: 0
    }

    RETURN vcs

FUNCTION TrackChanges(documents, vcs):
    changes = []

    FOR EACH doc IN documents:
        previousVersion = vcs.GetPrevious(doc.RelativePath)

        IF previousVersion == NULL:
            changes.APPEND({
                type: &quot;created&quot;,
                path: doc.RelativePath,
                content: doc.Content
            })
        ELSE IF doc.Content != previousVersion.Content:
            changes.APPEND({
                type: &quot;modified&quot;,
                path: doc.RelativePath,
                diff: GenerateDiff(previousVersion.Content, doc.Content)
            })

    // Check for deletions
    previousPaths = vcs.GetAllPaths()
    currentPaths = documents.MAP(d =&gt; d.RelativePath)

    FOR EACH path IN previousPaths:
        IF NOT currentPaths.CONTAINS(path):
            changes.APPEND({
                type: &quot;deleted&quot;,
                path: path
            })

    IF LENGTH(changes) &gt; 0:
        vcs.Commit(changes)
        BroadcastChanges(changes)

    RETURN changes
</code></pre>

<h2 id="8-web-server-implementation">8. Web Server Implementation</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION StartWebServer(config):
    server = CreateGinServer()

    // Static file serving
    server.Static(&quot;/&quot;, config.outputPath)

    // API endpoints
    server.GET(&quot;/api/docs&quot;, ListDocuments)
    server.GET(&quot;/api/docs/:id&quot;, GetDocument)
    server.GET(&quot;/api/search&quot;, SearchDocuments)
    server.GET(&quot;/api/toc&quot;, GetTableOfContents)
    server.GET(&quot;/api/export/:format&quot;, ExportDocumentation)

    // WebSocket for hot reload
    IF config.autoReload:
        server.GET(&quot;/ws&quot;, WebSocketHandler)
        StartFileWatcher(config.inputPaths, FUNCTION(change):
            BroadcastReload(change)
        )

    server.Run(&quot;:&quot; + config.port)

FUNCTION WebSocketHandler(connection):
    clients.ADD(connection)

    connection.ON(&quot;close&quot;, FUNCTION():
        clients.REMOVE(connection)
    )

    // Keep alive
    EVERY 30 seconds:
        connection.Send({type: &quot;ping&quot;})
</code></pre>

<h2 id="9-cli-command-handlers">9. CLI Command Handlers</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION HandleBuildCommand(flags):
    config = MergeConfigs(LoadConfigFile(), flags)

    ShowProgress(&quot;Scanning files...&quot;)
    documents = ScanMarkdownFiles(config.inputPaths, config.ignorePatterns)

    ShowProgress(&quot;Generating TOC...&quot;)
    toc = GenerateTableOfContents(documents)

    ShowProgress(&quot;Compiling HTML...&quot;)
    CompileToHTML(documents, toc, config.outputPath)

    IF config.features.search:
        ShowProgress(&quot;Building search index...&quot;)
        index = BuildSearchIndex(documents)
        WriteFile(JoinPath(config.outputPath, &quot;search-index.json&quot;), index)

    IF config.features.versioning:
        ShowProgress(&quot;Tracking changes...&quot;)
        TrackChanges(documents, vcs)

    ShowSuccess(&quot;Build complete! &quot; + LENGTH(documents) + &quot; files processed.&quot;)

FUNCTION HandleWatchCommand(flags):
    config = MergeConfigs(LoadConfigFile(), flags)

    // Initial build
    HandleBuildCommand(flags)

    // Watch for changes
    watcher = CreateFileWatcher(config.inputPaths)

    watcher.ON(&quot;change&quot;, FUNCTION(event):
        ShowInfo(&quot;Change detected: &quot; + event.path)

        // Incremental rebuild
        IF event.type == &quot;modify&quot; OR event.type == &quot;create&quot;:
            doc = CreateDocument(event.path, GetRelativePath(event.path))
            UpdateDocument(doc)
        ELSE IF event.type == &quot;delete&quot;:
            RemoveDocument(event.path)

        RebuildAffectedFiles()
    )

    ShowInfo(&quot;Watching for changes... Press Ctrl+C to stop.&quot;)
    watcher.Start()
</code></pre>

<h2 id="10-error-handling">10. Error Handling</h2>

<pre class="language-pseudocode"><code class="language-pseudocode">FUNCTION SafeExecute(operation, errorMessage):
    TRY:
        RETURN operation()
    CATCH error:
        LogError(error)

        IF IsFileNotFound(error):
            ShowError(errorMessage + &quot;: File not found - &quot; + error.path)
            ShowHint(&quot;Check if the file exists and you have read permissions&quot;)
        ELSE IF IsPermissionError(error):
            ShowError(errorMessage + &quot;: Permission denied - &quot; + error.path)
            ShowHint(&quot;Check file permissions or run with appropriate privileges&quot;)
        ELSE IF IsParseError(error):
            ShowError(errorMessage + &quot;: Parse error - &quot; + error.details)
            ShowHint(&quot;Check markdown syntax at line &quot; + error.line)
        ELSE:
            ShowError(errorMessage + &quot;: &quot; + error.message)

        IF config.debug:
            PrintStackTrace(error)

        EXIT(1)
</code></pre>

<p>This pseudocode provides a comprehensive design for all major components of the Jot documentation generator, ready for implementation in Go.</p>

                </article>
            </div>
        </main>
    </div>

    <script>
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        
        document.addEventListener('DOMContentLoaded', function() {
            
            document.querySelectorAll('pre').forEach(pre => {
                const button = document.createElement('button');
                button.className = 'copy-button';
                button.textContent = 'Copy';
                button.onclick = function() {
                    const code = pre.querySelector('code');
                    const text = code ? code.textContent : pre.textContent;

                    navigator.clipboard.writeText(text).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');

                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    });
                };
                pre.appendChild(button);
            });
        });

        
        const searchInput = document.querySelector('.search-input');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                
                console.log('Searching for:', query);
            });
        }

        
        document.querySelectorAll('.nav-section-title').forEach(title => {
            title.addEventListener('click', () => {
                const section = title.parentElement;
                section.classList.toggle('open');
            });
        });
    </script>
</body>
</html>