# Jot Documentation

> Modern documentation generator

# Changelog

# Changelog

All notable changes to Jot will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased] - 2025-10-12

### Fixed
- **Performance**: Replaced `WriteString(fmt.Sprintf(...))` with `fmt.Fprintf` in markdown compiler for better performance
- **Document Chunking**: Fixed overlap calculation in `chunkDocument` function to properly track character positions instead of mixing word indices with character counts
- **HTML Rendering**: Fixed code block rendering to properly add language classes to both `<pre>` and `<code>` tags for better syntax highlighting support
- **Breadcrumb Navigation**: Fixed breadcrumb path generation to use correct absolute paths for directories and files
- **Navigation Tree**: Added missing `nav-tree` class wrapper to navigation output
- **Template**: Updated page title format to include "Jot" branding
- **Test Suite**: Fixed test expectations to match actual implementation behavior

### Changed
- Improved document chunking algorithm for more accurate text segmentation with proper overlap handling

## [0.0.5] - 2025-10-07

### Added
- **GoDoc Generation**: Added comprehensive GoDoc comments to all Go source files in the `internal` and `cmd` directories to improve code clarity and maintainability. This includes documentation for all public types, functions, and methods.

### Changed
- Improved code documentation across the entire Go codebase.

## [0.0.4] - 2025-10-04

### Added
- **Local Development Server**: Implemented `jot serve` command for local documentation preview
  - HTTP server with configurable port (default 8080)
  - Automatic browser opening with cross-platform support (Linux, macOS, Windows)
  - Smart index handling (serves README.html as default, fallback to index.html)
  - Static file serving for CSS, JS, images, and other assets
  - Comprehensive error handling with helpful user guidance

### Features
- `--port, -p`: Set custom server port
- `--open, -o`: Control browser auto-opening (default: true)
- `--dir, -d`: Override serve directory (default: ./dist)

### Technical Improvements
- Proper HTTP file server implementation
- Cross-platform browser launching support
- Configuration integration with existing Viper setup
- Graceful error handling for missing build artifacts

## [0.0.3] - 2025-10-03

### Added
- Sidebar items are now collapsible dropdowns for better organization.

### Changed
- Updated navigation bar icon and background to a "dusk" themed gradient.
- Refactored CSS out of the HTML template into a separate `style.css` file.
- Updated the build process to copy the new `style.css` file to the output directory, reducing the size of generated HTML files.

## [0.0.2] - 2025-08-20

### Added

#### UI/UX Enhancements
- **Modern Glassmorphic Sidebar**: Complete redesign with glass-morphism effects
  - Collapsible sidebar (72px collapsed, 280px expanded)
  - Blur effects with backdrop-filter
  - Smooth cubic-bezier animations
  - Dark theme with refined color palette
- **macOS-Style Window Controls**: Traffic light controls (red, yellow, green)
  - Fade to gray when sidebar not hovered
  - Native macOS positioning and styling
- **Enhanced Navigation System**:
  - Icon-based navigation with SVG icons
  - Dynamic icon selection based on content type
  - Smooth expand/collapse animations
  - Active state indicators with accent colors
- **Profile & Search Integration**:
  - Gradient avatar display
  - Integrated search bar with icon
  - Opacity transitions on hover/expand
- **Refined Typography & Spacing**:
  - Improved font sizing and line heights
  - Better visual hierarchy
  - Optimized whitespace and padding

### Changed
- Updated HTML template generation for modern design
- Improved navigation node rendering with icons
- Enhanced color scheme for better readability
- Refined hover states and transitions
- Optimized sidebar interactions

### Technical Improvements
- Better CSS variable organization
- Improved responsive design patterns
- Enhanced animation performance
- Cleaner component architecture

## [0.0.1] - 2025-08-13

### Added

#### Core Features
- **File Scanner**: Recursive markdown file scanning with configurable ignore patterns
- **TOC Generator**: Hierarchical XML table of contents generation from document structure
- **HTML Renderer**: Markdown to HTML conversion with syntax highlighting and modern styling
- **Search Functionality**: Client-side full-text search with JSON index generation
- **CLI Interface**: Comprehensive command-line interface using Cobra framework
  - `init`: Initialize new documentation project
  - `build`: Build documentation from markdown files
  - `serve`: Start development server (planned)
  - `watch`: Watch for changes and rebuild (planned)
  - `export`: Export documentation in various formats

#### Document Processing
- Markdown parsing with Blackfriday v2
- Automatic heading extraction for navigation
- Smart internal link resolution (`.md` to `.html`)
- Relative path handling for all assets and links
- Breadcrumb navigation generation

#### Export Formats
- JSON export with document chunking for LLM consumption
- YAML export for configuration and data interchange
- Search index generation for client-side search

#### Styling and UI
- Professional syntax highlighting based on Tailwind CSS theme
- Dark mode support with automatic detection
- Responsive design for mobile and desktop
- Interactive code copy buttons
- Keyboard shortcuts (Ctrl+K for search)

#### Build and Distribution
- Single binary distribution with no runtime dependencies
- Cross-platform support (macOS, Linux, Windows)
- Docker container support
- Automated release workflow with GitHub Actions

### Technical Implementation
- Written in Go for performance and portability
- Test-Driven Development (TDD) approach
- SPARC methodology for systematic development
- Modular architecture with clear separation of concerns
- Comprehensive test coverage

### Documentation
- Complete requirements specification
- System architecture documentation
- Pseudocode design documents
- Usage examples and quick start guide

### Known Limitations
- Live reload not yet implemented
- Version control integration planned for future release
- LLM API endpoints planned for future release

## Future Releases

### [0.2.0] - Planned
- Live reload functionality for development server
- Version control and change tracking
- LLM/Agent API endpoints
- Multiple theme support

### [0.3.0] - Planned
- Plugin system
- Cloud deployment features
- Advanced search with filters
- Multi-language support

---

For more information, see the [README](../../README.md)


---

# Code of Conduct

# Code of Conduct

## Our Pledge

We pledge to make participation in our project a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to a positive environment:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior:

* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information without permission
* Other conduct which could reasonably be considered inappropriate

## Our Responsibilities

Project maintainers are responsible for clarifying standards of acceptable behavior and will take appropriate and fair corrective action in response to unacceptable behavior.

## Scope

This Code of Conduct applies within all project spaces and when an individual is representing the project or its community in public spaces.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue. All complaints will be reviewed and investigated promptly and fairly.

## Attribution

This Code of Conduct is adapted from the Contributor Covenant, version 2.0.


---

# Contributing to Jot

# Contributing to Jot

Thank you for your interest in contributing to Jot! This document provides guidelines for contributing to the project.

## Getting Started

1. Fork the repository
2. Clone your fork: `git clone https://github.com/YOUR_USERNAME/jot.git`
3. Create a feature branch: `git checkout -b feature/your-feature-name`
4. Make your changes
5. Run tests: `go test ./...`
6. Commit your changes
7. Push to your fork
8. Create a Pull Request

## Code Style

- Follow standard Go formatting (`gofmt`)
- Run `go vet` to catch common issues
- Keep functions focused and concise
- Add comments for exported functions and types
- Write idiomatic Go code

## Testing

- Write tests for new features
- Ensure existing tests pass
- Aim for good test coverage
- Use table-driven tests where appropriate

## Commit Messages

Use clear, descriptive commit messages:

```
type: brief description

Longer explanation if needed

Closes #issue-number
```

Types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`

## Pull Request Process

1. Update documentation for any changed functionality
2. Add tests for new features
3. Ensure CI passes
4. Request review from maintainers
5. Address review feedback
6. Squash commits if requested

## Questions?

Open an issue for discussion or reach out to the maintainers.


---

# Installing Jot

# Installing Jot

There are several ways to install Jot on your system. Choose the method that works best for your setup.

## Prerequisites

- Go 1.19 or later (for building from source)
- Git (for cloning the repository)

## Installation Methods

### Method 1: Using Go Install (Recommended)

The simplest way to install jot is using `go install`:

```bash
go install github.com/onedusk/jot/cmd/jot@latest
```

This installs jot to `$GOPATH/bin`. Make sure this directory is in your PATH:

```bash
export PATH="$PATH:$(go env GOPATH)/bin"
```

### Method 2: Using the Install Script

Clone the repository and run the install script:

```bash
git clone https://github.com/onedusk/jot.git
cd jot
./install.sh
```

The script will:
- Build the binary
- Install it to `/usr/local/bin` (may require sudo)
- Verify the installation

### Method 3: Using Make

If you have Make installed:

```bash
git clone https://github.com/onedusk/jot.git
cd jot
make install
```

This builds and installs jot to `/usr/local/bin` (requires sudo).

### Method 4: Manual Installation

1. Clone and build:
```bash
git clone https://github.com/onedusk/jot.git
cd jot
go build -o jot ./cmd/jot
```

2. Move to a directory in your PATH:
```bash
# Option A: User-specific installation (no sudo required)
mkdir -p ~/bin
mv jot ~/bin/
export PATH="$PATH:~/bin"  # Add to your shell profile

# Option B: System-wide installation (requires sudo)
sudo mv jot /usr/local/bin/
```

### Method 5: Download Pre-built Binary

Download the appropriate binary for your platform from the [releases page](https://github.com/onedusk/jot/releases):

```bash
# Example for macOS ARM64
curl -L https://github.com/onedusk/jot/releases/latest/download/jot-darwin-arm64.tar.gz | tar xz
sudo mv jot /usr/local/bin/
```

## Verifying Installation

After installation, verify that jot is working:

```bash
jot --version
jot --help
```

## Updating

To update jot to the latest version:

### If installed with go install:
```bash
go install github.com/onedusk/jot/cmd/jot@latest
```

### If installed from source:
```bash
cd jot
git pull
make clean install
```

## Uninstalling

### If installed to /usr/local/bin:
```bash
sudo rm /usr/local/bin/jot
```

### If installed with go install:
```bash
rm $(go env GOPATH)/bin/jot
```

### Using Make:
```bash
cd jot
make uninstall
```

## Troubleshooting

### Command not found

If you get "command not found" after installation, ensure the installation directory is in your PATH:

```bash
# For go install method
export PATH="$PATH:$(go env GOPATH)/bin"

# For /usr/local/bin installation
export PATH="$PATH:/usr/local/bin"

# For user bin directory
export PATH="$PATH:~/bin"
```

Add the appropriate export line to your shell profile (`~/.bashrc`, `~/.zshrc`, etc.) to make it permanent.

### Permission denied

If you get permission errors during installation:
- Use `sudo` for system-wide installation
- Choose a user-specific installation method that doesn't require sudo
- Use the `go install` method

### Build errors

Ensure you have:
- Go 1.19 or later: `go version`
- All dependencies: `go mod download`

## Platform-Specific Notes

### macOS

If you have Homebrew installed, you may want to ensure `/usr/local/bin` comes before system directories in your PATH to avoid conflicts with the BSD `jot` utility:

```bash
export PATH="/usr/local/bin:$PATH"
```

### Windows

On Windows, use the Windows binary from the releases page or build with:

```bash
go build -o jot.exe ./cmd/jot
```

Then add the directory containing `jot.exe` to your system PATH.

### Linux

Most Linux distributions include `/usr/local/bin` in the default PATH. If not, add it to your shell profile.

---

# Benchmarks

# Benchmarks

## Stripe Documentation

**Test Date:** 2025-01-15
**Dataset:** Stripe's documentation
**FIles:** 2,679 markdown files

## Results

```
❯❯ jotdoc build
✓ Scanning for markdown files...
  ✓ Scanning docs...
  ✓ Scanning README.md...
  ✓ Found 2679 markdown files

✓ Generating table of contents...
  ✓ Created dist/toc.xml

✓ Compiling to HTML...
  ✓ Generated 2679 HTML files
  ✓ Created assets/styles.css

✓ Build completed in 10.81s
```


---

# Roadmap

# Roadmap

## Current Version: 1.0

### ✅ Completed Features
- [x] Markdown to HTML compilation
- [x] XML Table of Contents generation
- [x] Multi-format export (JSON, YAML, LLM)
- [x] **Local development server** - HTTP server with browser auto-open
- [x] Symlink support for markdown access
- [x] Global installation as `jotdoc`
- [x] Clean path format (removed `./` prefixes)

## Version 1.1 (Quick Improvements)
*Timeline: 1-2 weeks*

- [ ] **Fix duplicate TOC entries** - Improve path deduplication logic
- [ ] **Better title extraction** - Support frontmatter, multiple heading formats
- [ ] **Markdown compiler** - Native markdown output with navigation
- [ ] **Config validation** - Verify jot.yml on load
- [ ] **Better error messages** - User-friendly error reporting

## Version 1.2 (Quality of Life)
*Timeline: 2-3 weeks*

- [ ] **Live reload** - Auto-refresh browser on file changes
- [ ] **Watch mode** - Auto-rebuild on file changes
- [ ] **Partial builds** - Only rebuild changed files
- [ ] **Theme support** - Multiple built-in themes
- [ ] **Custom CSS** - User-provided stylesheets
- [ ] **Plugin system** - Extensible processors

## Version 2.0 (Scale & Performance)
*Timeline: 1 month*

### Enhanced TOC Searchability ⭐
**[Full specification](docs/features/enhanced-toc-searchability.md)**

- [ ] **Metadata-rich TOC** (modified date, size, tags, summaries)
- [ ] **Search indexing** - Sub-50ms search at 5000+ docs
- [ ] **Category manifests** - Organized document groups
- [ ] **Content hashing** - Change detection & caching
- [ ] **LLM-optimized format** - 60% smaller context size

**Impact:** 30x faster searches at 1000 docs, 224x at 5000 docs

## Version 2.1 (Enterprise Features)
*Timeline: 2 months*

- [ ] **Multi-repository support** - Aggregate docs from multiple sources
- [ ] **Authentication** - Protected documentation
- [ ] **Versioning** - Multiple doc versions side-by-side
- [ ] **Search API** - RESTful/GraphQL endpoints
- [ ] **Analytics** - Usage tracking, popular pages

## Version 3.0 (AI-Enhanced)
*Timeline: 3-4 months*

- [ ] **Auto-tagging** - NLP-based document classification
- [ ] **Semantic search** - Meaning-based document discovery
- [ ] **Smart summaries** - AI-generated document summaries
- [ ] **Cross-reference suggestions** - Automatic linking
- [ ] **Quality scoring** - Documentation completeness metrics

## Experimental Features
*No timeline - research phase*

- [ ] **Real-time collaboration** - Multiple users editing
- [ ] **Git integration** - Version control awareness
- [ ] **IDE plugins** - VSCode, IntelliJ extensions
- [ ] **Mobile app** - iOS/Android documentation readers
- [ ] **PDF export** - Print-ready documentation

## Performance Benchmarks

### Current (v1.0)
| Documents | Build Time | TOC Search | Memory |
|-----------|------------|------------|---------|
| 100       | 0.8s       | 12ms       | 45MB    |
| 1000      | 8.2s       | 450ms      | 312MB   |

### Target (v2.0)
| Documents | Build Time | TOC Search | Memory |
|-----------|------------|------------|---------|
| 100       | 0.5s       | 3ms        | 40MB    |
| 1000      | 3.0s       | 15ms       | 200MB   |
| 5000      | 12s        | 38ms       | 800MB   |

## Contributing

Interested in contributing? Check out:
- [Open Issues](https://github.com/onedusk/jot/issues)
- [Development Guide](docs/development.md)
- [Architecture Overview](docs/architecture.md)

## Feedback

Have ideas for features? Found a bug?
- Open an issue: [GitHub Issues](https://github.com/onedusk/jot/issues)
- Email: jot@onedusk.dev

---

*Last updated: 2025-10-04*
*Next review: 2025-11-01*


---

# System Architecture

# System Architecture

## 1. High-Level Architecture

```


                     Core Engine


     Engine        Control          Export


## 2. Component Architecture

### 2.1 CLI Layer (`cmd/jot/`)

```go
cmd/jot/
 main.go              // Entry point
 serve.go             // Server command

**Responsibilities:**
- Parse command-line arguments
- Load configuration
- Orchestrate core operations
- Handle errors and display output

### 2.2 Core Engine (`internal/`)

```go
internal/
 scanner/
 toc/
 renderer/
    assets.go        // Asset management
     optimizer.go     // Output optimization
### 2.3 Service Layer (`internal/`)

```go
internal/
 search/
 vcs/
 api/
 export/
```

### 2.4 Package Layer (`pkg/`)

```go
pkg/
 config/
 logger/
     paths.go         // Path utilities

## 3. Data Models

### 3.1 Document Model

```go
type Document struct {
    ID           string                 // Unique identifier
    Path         string                 // Absolute file path
    RelativePath string                 // Relative to project root
    Title        string                 // Extracted title
    Content      []byte                 // Raw markdown content
    HTML         string                 // Rendered HTML
    Metadata     map[string]interface{} // Frontmatter data
    ModTime      time.Time              // Last modification
    Sections     []Section              // Document sections
    Links        []Link                 // Internal/external links
    CodeBlocks   []CodeBlock            // Code snippets
}

type Section struct {
    ID        string
    Title     string
    Level     int
    Content   string
    StartLine int
    EndLine   int
}
```

### 3.2 TOC Model

```go
type TOCNode struct {
    ID       string
    Title    string
    Path     string      // nil for directories
    Weight   int         // For custom ordering
    Children []*TOCNode
}

type TableOfContents struct {
    Version string
    Root    *TOCNode
    Index   map[string]*TOCNode // Fast lookup by ID
}
```

### 3.3 Search Model

```go
type SearchIndex struct {
    Version   string
    Documents []SearchDocument
    Terms     map[string][]TermOccurrence
    Fuzzy     *FuzzyIndex
}

type SearchResult struct {
    Document  SearchDocument
    Score     float64
    Snippets  []string
    Highlight map[string][]int // Term positions
}
```

## 4. API Design

### 4.1 RESTful Endpoints

```
GET    /api/v1/docs                 # List all documents
GET    /api/v1/docs/:id             # Get specific document
GET    /api/v1/search?q=query       # Search documents
GET    /api/v1/toc                  # Get table of contents
GET    /api/v1/export/:format       # Export documentation
POST   /api/v1/embeddings           # Generate embeddings
GET    /api/v1/changes              # Get recent changes
WS     /api/v1/ws                   # WebSocket for live updates
```

### 4.2 Response Formats

```json
// Document Response
{
  "id": "getting-started-installation",
  "path": "docs/getting-started/installation.md",
  "title": "Installation Guide",
  "content": "# Installation Guide\n...",
  "html": "<h1>Installation Guide</h1>...",
  "metadata": {
    "author": "John Doe",
    "tags": ["tutorial", "setup"]
  },
  "sections": [...],
  "links": {
    "internal": ["./quickstart.md"],
    "external": ["https://golang.org"]
  }
}

// Search Response
{
  "query": "install",
  "results": [
    {
      "document": {...},
      "score": 0.95,
      "snippets": [
        "...to <mark>install</mark> Jot, run the following..."
      ]
    }
  ],
  "total": 15,
  "took": 12
}
```

## 5. File Structure

### 5.1 Project Layout

```
jot-project/
 .jotignore           # Ignore patterns
    getting-started/
        reference.md
       installation.html
       js/
     temp/
### 5.2 Template Structure

```
web/templates/
 layouts/
    header.html      # Page header
    footer.html      # Page footer
        themes/      # Theme variations
         highlight.js # Syntax highlighting
## 6. Deployment Architecture

### 6.1 Binary Distribution

```
releases/
 jot-v0.1.0-darwin-amd64.tar.gz
 checksums.txt
### 6.2 Docker Support

```dockerfile
# Multi-stage build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o jot cmd/jot/main.go

FROM alpine:latest
RUN apk add --no-cache ca-certificates
COPY --from=builder /app/jot /usr/local/bin/
ENTRYPOINT ["jot"]
```

## 7. Performance Considerations

### 7.1 Concurrency Model

- **Parallel file scanning**: Worker pool for I/O operations
- **Concurrent rendering**: Process multiple documents simultaneously
- **Async search indexing**: Background index updates
- **Buffered WebSocket**: Efficient real-time updates

### 7.2 Caching Strategy

- **Template cache**: Pre-compiled templates
- **Markdown cache**: Parsed AST storage
- **Search cache**: Query result caching
- **Asset cache**: Compressed static files

### 7.3 Memory Management

- **Streaming**: Large file handling
- **Pooling**: Reusable buffers
- **Lazy loading**: On-demand processing
- **GC tuning**: Optimized for throughput

## 8. Security Architecture

### 8.1 Input Validation

- **Path sanitization**: Prevent directory traversal
- **Markdown sanitization**: XSS prevention
- **Config validation**: Type and range checks
- **API validation**: Request parameter validation

### 8.2 Access Control

- **Read-only by default**: No file modifications
- **Sandboxed execution**: Limited system access
- **Rate limiting**: API request throttling
- **CORS configuration**: Controlled cross-origin access

## 9. Extensibility

### 9.1 Plugin Interface

```go
type Plugin interface {
    Name() string
    Version() string
    Process(doc *Document) error
    RegisterAPI(router *gin.Engine)
}
```

### 9.2 Theme System

```yaml
theme:
  name: "custom-theme"
  extends: "default"
  variables:
    primary-color: "#007bff"
    font-family: "Inter, sans-serif"
  templates:
    - "custom-header.html"
```

## 10. Integration Points

### 10.1 CI/CD Integration

```yaml
# GitHub Actions Example
- name: Build Documentation
  uses: onedusk/jot-action@v1
  with:
    config: jot.yml
    output: ./dist

# GitLab CI Example
build-docs:
  image: onedusk/jot:latest
  script:
    - jot build
  artifacts:
    paths:
      - dist/
```

### 10.2 Editor Integration

- VS Code extension for live preview
- IntelliJ plugin for documentation generation
- Vim plugin for markdown validation

This architecture provides a scalable, maintainable foundation for the Jot documentation generator with clear separation of concerns and extensibility points.


---

# Pseudocode Design

# Pseudocode Design

## 1. Main Application Flow

```pseudocode
PROGRAM Jot

INITIALIZE:
    config = LoadConfiguration()
    logger = SetupLogging()

MAIN:
    command = ParseCLIArguments()

    SWITCH command:
        CASE "init":
            InitializeProject()
        CASE "build":
            BuildDocumentation()
        CASE "serve":
            StartWebServer()
        CASE "watch":
            WatchAndRebuild()
        CASE "export":
            ExportForLLM()
        DEFAULT:
            ShowHelp()
```

## 2. File Scanning Algorithm

```pseudocode
FUNCTION ScanMarkdownFiles(rootPath, ignorePatterns):
    documents = []
    ignorer = CreateIgnoreFilter(ignorePatterns)

    FUNCTION WalkDirectory(path, relativePath):
        entries = ReadDirectory(path)

        FOR EACH entry IN entries:
            fullPath = JoinPath(path, entry.name)
            relPath = JoinPath(relativePath, entry.name)

            IF ignorer.ShouldIgnore(relPath):
                CONTINUE

            IF entry.IsDirectory():
                WalkDirectory(fullPath, relPath)
            ELSE IF entry.HasExtension(".md"):
                doc = CreateDocument(fullPath, relPath)
                documents.APPEND(doc)

    WalkDirectory(rootPath, "")
    RETURN documents

FUNCTION CreateDocument(filePath, relativePath):
    content = ReadFile(filePath)
    metadata = ExtractFrontmatter(content)
    title = ExtractTitle(content, metadata)

    RETURN Document{
        Path: filePath,
        RelativePath: relativePath,
        Content: content,
        Title: title,
        Metadata: metadata,
        ModTime: GetFileModTime(filePath)
    }
```

## 3. TOC Generation Algorithm

```pseudocode
FUNCTION GenerateTableOfContents(documents):
    root = TOCNode{Title: "Root", Children: []}

    FOR EACH doc IN documents:
        pathParts = SplitPath(doc.RelativePath)
        currentNode = root

        FOR i = 0 TO LENGTH(pathParts) - 1:
            part = pathParts[i]
            isFile = (i == LENGTH(pathParts) - 1)

            child = FindChildByName(currentNode, part)

            IF child == NULL:
                child = TOCNode{
                    ID: GenerateID(pathParts[0:i+1]),
                    Title: IF isFile THEN doc.Title ELSE Humanize(part),
                    Path: IF isFile THEN doc.RelativePath ELSE NULL,
                    Children: []
                }
                currentNode.Children.APPEND(child)

            currentNode = child

    RETURN ConvertToXML(root)

FUNCTION ConvertToXML(node):
    xml = "<toc version='1.0'>\n"

    FUNCTION ProcessNode(n, depth):
        indent = REPEAT("  ", depth)

        IF n.Path != NULL:
            xml += indent + "<chapter id='" + n.ID + "' path='" + n.Path + "'>\n"
        ELSE:
            xml += indent + "<section id='" + n.ID + "'>\n"

        xml += indent + "  <title>" + EscapeXML(n.Title) + "</title>\n"

        FOR EACH child IN n.Children:
            ProcessNode(child, depth + 1)

        xml += indent + (IF n.Path != NULL THEN "</chapter>\n" ELSE "</section>\n")

    FOR EACH child IN node.Children:
        ProcessNode(child, 1)

    xml += "</toc>"
    RETURN xml
```

## 4. HTML Compilation Algorithm

```pseudocode
FUNCTION CompileToHTML(documents, tocXML, outputPath):
    toc = ParseXML(tocXML)
    linkMap = BuildLinkMap(documents)

    FOR EACH doc IN documents:
        html = ConvertMarkdownToHTML(doc.Content)
        html = ResolveInternalLinks(html, linkMap)
        html = AddSyntaxHighlighting(html)

        pageData = {
            Title: doc.Title,
            Content: html,
            TOC: toc,
            Breadcrumb: GenerateBreadcrumb(doc.RelativePath),
            Navigation: GenerateNavigation(doc, documents)
        }

        finalHTML = RenderTemplate("page.html", pageData)
        outputFile = JoinPath(outputPath, ChangeExtension(doc.RelativePath, ".html"))

        CreateDirectories(GetDirectory(outputFile))
        WriteFile(outputFile, finalHTML)

    CopyAssets(outputPath)
    GenerateSearchIndex(documents, outputPath)

FUNCTION ResolveInternalLinks(html, linkMap):
    PATTERN = /\[([^\]]+)\]\(([^)]+\.md[^)]*)\)/g

    RETURN html.REPLACE(PATTERN, FUNCTION(match, text, link):
        cleanLink = RemoveFragment(link)

        IF linkMap.HAS(cleanLink):
            htmlLink = ChangeExtension(linkMap[cleanLink], ".html")
            RETURN "[" + text + "](" + htmlLink + ")"
        ELSE:
            RETURN match
    )
```

## 5. Search Implementation

```pseudocode
FUNCTION BuildSearchIndex(documents):
    index = {
        documents: [],
        terms: {},
        fuzzy: FuzzyMatcher{}
    }

    FOR EACH doc IN documents:
        docIndex = LENGTH(index.documents)

        index.documents.APPEND({
            id: doc.RelativePath,
            title: doc.Title,
            path: ChangeExtension(doc.RelativePath, ".html")
        })

        // Extract and index terms
        terms = ExtractTerms(doc.Content + " " + doc.Title)

        FOR EACH term IN terms:
            normalizedTerm = Normalize(term)

            IF NOT index.terms.HAS(normalizedTerm):
                index.terms[normalizedTerm] = []

            index.terms[normalizedTerm].APPEND({
                doc: docIndex,
                count: CountOccurrences(doc.Content, term),
                positions: FindPositions(doc.Content, term)
            })

            index.fuzzy.Add(normalizedTerm)

    RETURN index

FUNCTION Search(query, index):
    results = []
    queryTerms = ExtractTerms(query)

    FOR EACH term IN queryTerms:
        normalized = Normalize(term)

        // Exact matches
        IF index.terms.HAS(normalized):
            FOR EACH occurrence IN index.terms[normalized]:
                AddToResults(results, occurrence)

        // Fuzzy matches
        fuzzyMatches = index.fuzzy.Find(normalized, maxDistance: 2)
        FOR EACH match IN fuzzyMatches:
            IF index.terms.HAS(match):
                FOR EACH occurrence IN index.terms[match]:
                    AddToResults(results, occurrence, fuzzyPenalty: 0.8)

    // Sort by relevance
    results.SORT(BY relevance DESCENDING)

    RETURN results.TAKE(maxResults: 20)
```

## 6. LLM Export Algorithm

```pseudocode
FUNCTION ExportForLLM(documents, format):
    SWITCH format:
        CASE "json":
            RETURN ExportJSON(documents)
        CASE "yaml":
            RETURN ExportYAML(documents)
        CASE "embeddings":
            RETURN GenerateEmbeddings(documents)

FUNCTION ExportJSON(documents):
    export = {
        version: "1.0",
        generated: CurrentTimestamp(),
        project: LoadProjectMetadata(),
        documents: []
    }

    FOR EACH doc IN documents:
        sections = ExtractSections(doc.Content)
        codeBlocks = ExtractCodeBlocks(doc.Content)
        links = ExtractLinks(doc.Content)

        export.documents.APPEND({
            id: GenerateDocID(doc.RelativePath),
            path: doc.RelativePath,
            title: doc.Title,
            content: doc.Content,
            html: ConvertToHTML(doc.Content),
            sections: sections,
            metadata: doc.Metadata,
            links: links,
            codeBlocks: codeBlocks
        })

    export.index = BuildSemanticIndex(export.documents)

    RETURN JSONStringify(export, pretty: true)

FUNCTION GenerateEmbeddings(documents):
    embeddings = []

    FOR EACH doc IN documents:
        chunks = SplitIntoChunks(doc.Content, maxTokens: 512, overlap: 128)

        FOR EACH chunk IN chunks:
            embedding = {
                documentId: doc.RelativePath,
                chunkId: GenerateChunkID(),
                text: chunk.text,
                vector: NULL,  // Placeholder for actual embedding
                metadata: {
                    title: doc.Title,
                    section: chunk.section,
                    startLine: chunk.startLine,
                    endLine: chunk.endLine
                }
            }

            embeddings.APPEND(embedding)

    RETURN embeddings
```

## 7. Version Control Integration

```pseudocode
FUNCTION InitializeVersionControl():
    vcs = {
        store: CreateFileStore(".jot-history"),
        currentVersion: 0
    }

    RETURN vcs

FUNCTION TrackChanges(documents, vcs):
    changes = []

    FOR EACH doc IN documents:
        previousVersion = vcs.GetPrevious(doc.RelativePath)

        IF previousVersion == NULL:
            changes.APPEND({
                type: "created",
                path: doc.RelativePath,
                content: doc.Content
            })
        ELSE IF doc.Content != previousVersion.Content:
            changes.APPEND({
                type: "modified",
                path: doc.RelativePath,
                diff: GenerateDiff(previousVersion.Content, doc.Content)
            })

    // Check for deletions
    previousPaths = vcs.GetAllPaths()
    currentPaths = documents.MAP(d => d.RelativePath)

    FOR EACH path IN previousPaths:
        IF NOT currentPaths.CONTAINS(path):
            changes.APPEND({
                type: "deleted",
                path: path
            })

    IF LENGTH(changes) > 0:
        vcs.Commit(changes)
        BroadcastChanges(changes)

    RETURN changes
```

## 8. Web Server Implementation

```pseudocode
FUNCTION StartWebServer(config):
    server = CreateGinServer()

    // Static file serving
    server.Static("/", config.outputPath)

    // API endpoints
    server.GET("/api/docs", ListDocuments)
    server.GET("/api/docs/:id", GetDocument)
    server.GET("/api/search", SearchDocuments)
    server.GET("/api/toc", GetTableOfContents)
    server.GET("/api/export/:format", ExportDocumentation)

    // WebSocket for hot reload
    IF config.autoReload:
        server.GET("/ws", WebSocketHandler)
        StartFileWatcher(config.inputPaths, FUNCTION(change):
            BroadcastReload(change)
        )

    server.Run(":" + config.port)

FUNCTION WebSocketHandler(connection):
    clients.ADD(connection)

    connection.ON("close", FUNCTION():
        clients.REMOVE(connection)
    )

    // Keep alive
    EVERY 30 seconds:
        connection.Send({type: "ping"})
```

## 9. CLI Command Handlers

```pseudocode
FUNCTION HandleBuildCommand(flags):
    config = MergeConfigs(LoadConfigFile(), flags)

    ShowProgress("Scanning files...")
    documents = ScanMarkdownFiles(config.inputPaths, config.ignorePatterns)

    ShowProgress("Generating TOC...")
    toc = GenerateTableOfContents(documents)

    ShowProgress("Compiling HTML...")
    CompileToHTML(documents, toc, config.outputPath)

    IF config.features.search:
        ShowProgress("Building search index...")
        index = BuildSearchIndex(documents)
        WriteFile(JoinPath(config.outputPath, "search-index.json"), index)

    IF config.features.versioning:
        ShowProgress("Tracking changes...")
        TrackChanges(documents, vcs)

    ShowSuccess("Build complete! " + LENGTH(documents) + " files processed.")

FUNCTION HandleWatchCommand(flags):
    config = MergeConfigs(LoadConfigFile(), flags)

    // Initial build
    HandleBuildCommand(flags)

    // Watch for changes
    watcher = CreateFileWatcher(config.inputPaths)

    watcher.ON("change", FUNCTION(event):
        ShowInfo("Change detected: " + event.path)

        // Incremental rebuild
        IF event.type == "modify" OR event.type == "create":
            doc = CreateDocument(event.path, GetRelativePath(event.path))
            UpdateDocument(doc)
        ELSE IF event.type == "delete":
            RemoveDocument(event.path)

        RebuildAffectedFiles()
    )

    ShowInfo("Watching for changes... Press Ctrl+C to stop.")
    watcher.Start()
```

## 10. Error Handling

```pseudocode
FUNCTION SafeExecute(operation, errorMessage):
    TRY:
        RETURN operation()
    CATCH error:
        LogError(error)

        IF IsFileNotFound(error):
            ShowError(errorMessage + ": File not found - " + error.path)
            ShowHint("Check if the file exists and you have read permissions")
        ELSE IF IsPermissionError(error):
            ShowError(errorMessage + ": Permission denied - " + error.path)
            ShowHint("Check file permissions or run with appropriate privileges")
        ELSE IF IsParseError(error):
            ShowError(errorMessage + ": Parse error - " + error.details)
            ShowHint("Check markdown syntax at line " + error.line)
        ELSE:
            ShowError(errorMessage + ": " + error.message)

        IF config.debug:
            PrintStackTrace(error)

        EXIT(1)
```

This pseudocode provides a comprehensive design for all major components of the Jot documentation generator, ready for implementation in Go.


---

# Requirements Spec.

# Requirements Spec.

## 1. Executive Summary

Jot is a modern documentation generator designed to replace JetBrains' deprecated Writerside IDE. It provides a fast, simple, and platform-independent solution for aggregating markdown files into deployable web documentation with advanced features for LLM/AI integration.

## 2. Functional Requirements

### 2.1 File Scanning System
- **FR-001**: Recursively scan directories for markdown files (*.md)
- **FR-002**: Support configurable ignore patterns (.jotignore file)
- **FR-003**: Preserve original directory structure and file metadata
- **FR-004**: Handle symlinks and nested directories gracefully
- **FR-005**: Support glob patterns for include/exclude rules

### 2.2 Table of Contents Generation
- **FR-006**: Generate hierarchical XML TOC from file structure
- **FR-007**: Extract titles from H1 tags or frontmatter
- **FR-008**: Support custom ordering (weight-based or alphabetical)
- **FR-009**: Handle multi-level nesting (unlimited depth)
- **FR-010**: Auto-generate unique IDs for each entry

### 2.3 HTML Compilation
- **FR-011**: Convert markdown to semantic HTML5
- **FR-012**: Automatically resolve cross-references between documents
- **FR-013**: Generate navigation elements (breadcrumbs, sidebar, TOC)
- **FR-014**: Support syntax highlighting for code blocks
- **FR-015**: Bundle CSS/JS assets with optimization

### 2.4 LLM/Agent Integration
- **FR-016**: Export documentation as structured JSON
- **FR-017**: Generate YAML format for configuration tools
- **FR-018**: Create vector embeddings for semantic search
- **FR-019**: Provide RESTful API for programmatic access
- **FR-020**: Support chunk-based content splitting

### 2.5 Search Functionality
- **FR-021**: Full-text search across all documentation
- **FR-022**: Fuzzy matching for typo tolerance
- **FR-023**: Real-time search suggestions
- **FR-024**: Search result highlighting
- **FR-025**: Pre-built search indices for performance

### 2.6 Version Control
- **FR-026**: Track file changes with simple history
- **FR-027**: Generate diffs between versions
- **FR-028**: Support webhook notifications for changes
- **FR-029**: Integrate with git for change detection
- **FR-030**: Maintain change logs

### 2.7 CLI Interface
- **FR-031**: Command-line interface using Cobra framework
- **FR-032**: Support init, build, serve, watch commands
- **FR-033**: Configurable via flags and config files
- **FR-034**: Provide helpful error messages and usage guides
- **FR-035**: Support batch operations

### 2.8 Web Server
- **FR-036**: Built-in development server with Gin
- **FR-037**: Hot reload on file changes
- **FR-038**: CORS support for API access
- **FR-039**: Static file serving with caching
- **FR-040**: WebSocket support for live updates

## 3. Non-Functional Requirements

### 3.1 Performance
- **NFR-001**: Build time < 1 second for 1000 files
- **NFR-002**: Search latency < 50ms
- **NFR-003**: Memory usage < 100MB for typical projects
- **NFR-004**: Startup time < 500ms
- **NFR-005**: Support projects with 10,000+ files

### 3.2 Usability
- **NFR-006**: Single binary distribution (no dependencies)
- **NFR-007**: Cross-platform support (Windows, macOS, Linux)
- **NFR-008**: Intuitive CLI with helpful documentation
- **NFR-009**: Zero-config operation with sensible defaults
- **NFR-010**: Clear error messages with resolution hints

### 3.3 Security
- **NFR-011**: Input sanitization to prevent XSS
- **NFR-012**: Path traversal protection
- **NFR-013**: Rate limiting on API endpoints
- **NFR-014**: Secure defaults for web server
- **NFR-015**: No execution of user content

### 3.4 Compatibility
- **NFR-016**: CommonMark compliant markdown parsing
- **NFR-017**: Standard HTML5 output
- **NFR-018**: JSON Schema compliant exports
- **NFR-019**: OpenAPI specification for APIs
- **NFR-020**: UTF-8 encoding throughout

## 4. User Stories

### 4.1 Developer Stories
- As a developer, I want to generate documentation from my markdown files with a single command
- As a developer, I want to preview my documentation locally with hot reload
- As a developer, I want to customize the look and feel with themes
- As a developer, I want to integrate documentation generation into my CI/CD pipeline

### 4.2 AI/LLM Stories
- As an AI system, I want to access documentation via structured JSON API
- As an LLM, I want to search documentation semantically using embeddings
- As an agent, I want to retrieve specific sections without parsing HTML
- As a chatbot, I want to get contextual information about code examples

### 4.3 End User Stories
- As a user, I want to search documentation quickly and accurately
- As a user, I want to navigate between related topics easily
- As a user, I want to view documentation offline
- As a user, I want to access documentation on any device

## 5. Acceptance Criteria

### 5.1 File Scanning
-  Discovers all markdown files in specified directories
-  JSON output validates against schema
- Must use only standard library where possible
- Must compile to a single binary
- Must work offline (no external dependencies)
- Must be open source friendly

## 7. Dependencies

- Go 1.21+ (build time only)
- Gin web framework
- Cobra CLI framework
- Blackfriday markdown parser
- No runtime dependencies

## 8. Success Metrics

- Adoption by 100+ projects in first 3 months
- 95%+ user satisfaction in surveys
- <5 critical bugs in first release
- Performance targets met in 95% of use cases
- Active community contributions


